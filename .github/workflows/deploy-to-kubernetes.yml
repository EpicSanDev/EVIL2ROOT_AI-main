name: Build and Deploy to Kubernetes

on:
  push:
    branches: [ main ]

env:
  DIGITALOCEAN_REGISTRY: registry.digitalocean.com/evil2root-registry
  DEPLOYMENT_NAME: evil2root-ai
  NAMESPACE: evil2root-trading

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2

      - name: Login to Docker Registry
        uses: docker/login-action@v2
        with:
          registry: registry.digitalocean.com
          username: ${{ secrets.DIGITALOCEAN_ACCESS_TOKEN }}
          password: ${{ secrets.DIGITALOCEAN_ACCESS_TOKEN }}

      - name: Build and push Docker image
        uses: docker/build-push-action@v4
        with:
          context: .
          push: true
          tags: ${{ env.DIGITALOCEAN_REGISTRY }}/${{ env.DEPLOYMENT_NAME }}:latest,${{ env.DIGITALOCEAN_REGISTRY }}/${{ env.DEPLOYMENT_NAME }}:${{ github.sha }}
          cache-from: type=registry,ref=${{ env.DIGITALOCEAN_REGISTRY }}/${{ env.DEPLOYMENT_NAME }}:buildcache
          cache-to: type=registry,ref=${{ env.DIGITALOCEAN_REGISTRY }}/${{ env.DEPLOYMENT_NAME }}:buildcache,mode=max

      - name: Install doctl
        uses: digitalocean/action-doctl@v2
        with:
          token: ${{ secrets.DIGITALOCEAN_ACCESS_TOKEN }}

      - name: Create Kubernetes cluster if it doesn't exist
        run: |
          # Vérifier si le cluster existe déjà
          if ! doctl kubernetes cluster get evil2root-trading &>/dev/null; then
            echo "Le cluster n'existe pas. Création du cluster Kubernetes..."
            
            # Créer un nouveau cluster Kubernetes
            doctl kubernetes cluster create evil2root-trading \
              --region fra1 \
              --size s-2vcpu-4gb \
              --count 4 \
              --auto-upgrade=true \
              --ha=true
            
            echo "Cluster Kubernetes créé avec succès."
          else
            echo "Le cluster Kubernetes existe déjà."
          fi
          
          # Enregistrer le fichier kubeconfig
          doctl kubernetes cluster kubeconfig save evil2root-trading

      - name: Create registry secret
        run: |
          # Création du namespace s'il n'existe pas
          kubectl create namespace ${{ env.NAMESPACE }} --dry-run=client -o yaml | kubectl apply -f -
          
          # Création du secret pour le registre DigitalOcean
          kubectl create secret docker-registry registry-evil2root-registry \
            --namespace=${{ env.NAMESPACE }} \
            --docker-server=registry.digitalocean.com \
            --docker-username=${{ secrets.DIGITALOCEAN_ACCESS_TOKEN }} \
            --docker-password=${{ secrets.DIGITALOCEAN_ACCESS_TOKEN }} \
            --docker-email=${{ secrets.NOTIFICATION_EMAIL }} \
            --dry-run=client -o yaml | kubectl apply -f -

      - name: Create application secrets
        run: |
          # Application des secrets à partir d'un fichier YAML avec substitution des variables d'environnement
          cat <<EOF > temp-secrets.yaml
          apiVersion: v1
          kind: Secret
          metadata:
            name: trading-bot-secrets
            namespace: ${{ env.NAMESPACE }}
          type: Opaque
          stringData:
            DB_USER: "${{ secrets.DB_USER || 'postgres' }}"
            DB_PASSWORD: "${{ secrets.DB_PASSWORD || 'changeme' }}"
            DB_NAME: "${{ secrets.DB_NAME || 'tradingbot' }}"
            REDIS_PASSWORD: "${{ secrets.REDIS_PASSWORD || 'changeme' }}"
            GRAFANA_ADMIN_USER: "${{ secrets.GRAFANA_ADMIN_USER || 'admin' }}"
            GRAFANA_ADMIN_PASSWORD: "${{ secrets.GRAFANA_ADMIN_PASSWORD || 'admin' }}"
          EOF
          
          kubectl apply -f temp-secrets.yaml
          rm temp-secrets.yaml

      - name: Deploy infrastructure components
        run: |
          # Installation de metrics-server s'il n'est pas déjà installé
          if ! kubectl get deployment metrics-server -n kube-system &> /dev/null; then
            echo "Installation de metrics-server..."
            kubectl apply -f https://github.com/kubernetes-sigs/metrics-server/releases/latest/download/components.yaml
          else
            echo "Le metrics-server est déjà installé."
          fi
          
          # Installation de Nginx Ingress Controller s'il n'est pas déjà installé
          if ! kubectl get namespace ingress-nginx &> /dev/null; then
            echo "Installation de Nginx Ingress Controller..."
            kubectl apply -f https://raw.githubusercontent.com/kubernetes/ingress-nginx/controller-v1.8.2/deploy/static/provider/cloud/deploy.yaml
          else
            echo "Nginx Ingress Controller est déjà installé."
          fi
          
          # Déploiement des services de base (Redis, PostgreSQL)
          kubectl apply -f kubernetes/services/redis.yaml || echo "Erreur lors du déploiement de Redis, assurez-vous que le fichier existe"
          kubectl apply -f kubernetes/services/postgres.yaml || echo "Erreur lors du déploiement de PostgreSQL, assurez-vous que le fichier existe"

      - name: Deploy application components
        run: |
          # Déploiement des composants de l'application
          kubectl apply -f kubernetes/deployments/trading-bot-web.yaml
          kubectl apply -f kubernetes/deployments/analysis-bot.yaml
          kubectl apply -f kubernetes/deployments/market-scheduler.yaml
          
          # Déploiement des services
          kubectl apply -f kubernetes/services/trading-bot-web.yaml
          kubectl apply -f kubernetes/services/web-service.yaml
          
          # Déploiement de l'ingress
          kubectl apply -f kubernetes/ingress/trading-bot-web-ingress.yaml
          
          # Déploiement des autoscalers
          kubectl apply -f kubernetes/hpa/trading-bot-web-hpa.yaml
          kubectl apply -f kubernetes/hpa/analysis-bot-hpa.yaml
          
          echo "Application déployée avec succès !"

      - name: Wait for services and create report
        run: |
          echo "Attente de l'initialisation des services..."
          sleep 30
          
          # Récupérer et afficher l'IP externe du service
          echo "Récupération de l'IP externe..."
          
          MAX_RETRIES=20
          RETRY_COUNT=0
          
          until [ $RETRY_COUNT -ge $MAX_RETRIES ]; do
            EXTERNAL_IP=$(kubectl get svc -n ${{ env.NAMESPACE }} web-service -o jsonpath='{.status.loadBalancer.ingress[0].ip}' 2>/dev/null)
            
            if [ -n "$EXTERNAL_IP" ] && [ "$EXTERNAL_IP" != "<pending>" ]; then
              echo "Application déployée avec succès !"
              echo "Vous pouvez accéder à l'application en utilisant l'IP: $EXTERNAL_IP"
              
              # Enregistrer l'IP dans une variable d'environnement GitHub
              echo "EXTERNAL_IP=$EXTERNAL_IP" >> $GITHUB_ENV
              break
            fi
            
            RETRY_COUNT=$((RETRY_COUNT+1))
            echo "En attente de l'IP externe... ($RETRY_COUNT/$MAX_RETRIES)"
            sleep 15
          done
          
          # Afficher l'état actuel des pods
          echo "État actuel des pods:"
          kubectl get pods -n ${{ env.NAMESPACE }}
          
          # Afficher l'état actuel des services
          echo "État actuel des services:"
          kubectl get services -n ${{ env.NAMESPACE }}
          
          # Afficher l'état actuel de l'ingress
          echo "État actuel de l'ingress:"
          kubectl get ingress -n ${{ env.NAMESPACE }}

      - name: Ajouter l'IP au README
        run: |
          if [ -n "$EXTERNAL_IP" ]; then
            # Crée ou met à jour un fichier ACCESS.md avec l'IP
            cat > ACCESS.md << EOF
          # Accès à l'application Evil2Root Trading AI
          
          L'application est déployée et accessible via l'adresse IP suivante:
          
          **IP:** $EXTERNAL_IP
          
          Vous pouvez y accéder directement dans votre navigateur en visitant:
          
          http://$EXTERNAL_IP
          
          ## Connexion à l'API
          
          L'API est accessible à:
          
          http://$EXTERNAL_IP/api
          
          ## Surveillance et métriques
          
          Les métriques sont disponibles à:
          
          http://$EXTERNAL_IP/metrics
          EOF
            
            # Commit et push du fichier ACCESS.md
            git config --local user.email "github-actions[bot]@users.noreply.github.com"
            git config --local user.name "github-actions[bot]"
            git add ACCESS.md
            git commit -m "Mise à jour de l'IP d'accès [skip ci]"
            git push
          fi 