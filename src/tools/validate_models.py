#!/usr/bin/env python
"""
Script de validation des mod√®les SQLAlchemy

Ce script parcourt automatiquement tous les mod√®les SQLAlchemy du projet
et v√©rifie les erreurs courantes sans avoir besoin de cr√©er les tables.
"""

import os
import sys
import importlib
import inspect
import pkgutil
from pathlib import Path
from typing import List, Dict, Any, Set, Tuple
import traceback

# Ajoutez le r√©pertoire du projet au path Python
project_root = str(Path(__file__).resolve().parent.parent.parent)
sys.path.insert(0, project_root)

from sqlalchemy import inspect as sa_inspect, Column
from sqlalchemy.ext.declarative import DeclarativeMeta
from sqlalchemy.orm import RelationshipProperty

# Liste des mots r√©serv√©s SQLAlchemy √† √©viter comme noms d'attributs
SQLALCHEMY_RESERVED_NAMES = {
    'metadata', 'query', 'query_class', '__tablename__', '__table__', '__mapper__',
    'registry', '_decl_class_registry', '_sa_class_manager', '__dict__', 
    '__weakref__', '__init__', '__new__', '__repr__', '__str__'
}

# R√©pertoires √† analyser (relatifs √† src/)
MODEL_DIRECTORIES = [
    'api/database/models',
    'models',
    'core/models'
]

def is_sqlalchemy_model(cls: Any) -> bool:
    """V√©rifie si une classe est un mod√®le SQLAlchemy."""
    return isinstance(cls, DeclarativeMeta)

def get_all_python_files(base_dir: str) -> List[str]:
    """R√©cup√®re tous les fichiers Python dans le r√©pertoire sp√©cifi√© de mani√®re r√©cursive."""
    python_files = []
    
    for root, _, files in os.walk(base_dir):
        for file in files:
            if file.endswith('.py') and not file.startswith('__'):
                python_files.append(os.path.join(root, file))
    
    return python_files

def import_module_from_path(file_path: str) -> Any:
    """Importe un module Python √† partir de son chemin de fichier."""
    module_path = file_path.replace(project_root, '').replace('/', '.').replace('\\', '.').lstrip('.')
    
    if module_path.endswith('.py'):
        module_path = module_path[:-3]
    
    try:
        return importlib.import_module(module_path)
    except Exception as e:
        print(f"Erreur lors de l'importation de {module_path}: {e}")
        return None

def find_sqlalchemy_models() -> Dict[str, Dict[str, Any]]:
    """Trouve tous les mod√®les SQLAlchemy dans les r√©pertoires sp√©cifi√©s."""
    models = {}
    
    for dir_name in MODEL_DIRECTORIES:
        base_dir = os.path.join(project_root, 'src', dir_name)
        
        if not os.path.exists(base_dir):
            continue
        
        python_files = get_all_python_files(base_dir)
        
        for file_path in python_files:
            module = import_module_from_path(file_path)
            
            if not module:
                continue
            
            for name, obj in inspect.getmembers(module):
                if inspect.isclass(obj) and is_sqlalchemy_model(obj) and obj.__module__ == module.__name__:
                    models[obj.__name__] = {
                        'class': obj,
                        'file_path': file_path,
                        'module_name': module.__name__
                    }
    
    return models

def check_reserved_names(model_cls: Any) -> List[str]:
    """V√©rifie si le mod√®le utilise des noms r√©serv√©s par SQLAlchemy."""
    errors = []
    
    for name in dir(model_cls):
        if name in SQLALCHEMY_RESERVED_NAMES and not name.startswith('__'):
            if hasattr(model_cls, name) and isinstance(getattr(model_cls, name), Column):
                errors.append(f"Le mod√®le '{model_cls.__name__}' utilise le nom r√©serv√© '{name}' comme nom de colonne")
    
    return errors

def check_relationship_integrity(models: Dict[str, Dict[str, Any]]) -> Dict[str, List[str]]:
    """V√©rifie l'int√©grit√© des relations entre les mod√®les."""
    relation_errors = {}
    
    for model_name, model_info in models.items():
        model_cls = model_info['class']
        errors = []
        
        mapper = sa_inspect(model_cls)
        
        for rel in mapper.relationships:
            target_model = rel.mapper.class_
            target_model_name = target_model.__name__
            
            if target_model_name not in models and target_model_name != model_name:
                errors.append(f"Relation '{rel.key}' fait r√©f√©rence au mod√®le '{target_model_name}' qui n'a pas √©t√© trouv√©")
            
            # V√©rifier la coh√©rence des relations back_populates/backref
            if rel.back_populates:
                if not hasattr(target_model, rel.back_populates):
                    errors.append(f"La relation '{rel.key}' sp√©cifie back_populates='{rel.back_populates}', mais '{target_model_name}' n'a pas cet attribut")
                else:
                    target_rel = getattr(sa_inspect(target_model).all_orm_descriptors, rel.back_populates, None)
                    if not isinstance(target_rel, RelationshipProperty):
                        errors.append(f"L'attribut back_populates='{rel.back_populates}' sur '{model_name}.{rel.key}' n'est pas une relation")
        
        if errors:
            relation_errors[model_name] = errors
    
    return relation_errors

def check_table_names(models: Dict[str, Dict[str, Any]]) -> Dict[str, List[str]]:
    """V√©rifie les noms de tables pour s'assurer qu'ils sont coh√©rents."""
    table_errors = {}
    
    for model_name, model_info in models.items():
        model_cls = model_info['class']
        errors = []
        
        # V√©rifier si __tablename__ est d√©fini
        if not hasattr(model_cls, '__tablename__') and not hasattr(model_cls, '__table__'):
            # SQLAlchemy g√©n√®re automatiquement le nom, v√©rifier s'il est correct
            expected_tablename = model_name.lower()
            actual_tablename = model_cls.__tablename__ if hasattr(model_cls, '__tablename__') else None
            
            if actual_tablename and actual_tablename != expected_tablename:
                errors.append(f"Le nom de table '{actual_tablename}' est diff√©rent de la convention (le nom devrait √™tre '{expected_tablename}')")
        
        if errors:
            table_errors[model_name] = errors
    
    return table_errors

def validate_class_instantiation(models: Dict[str, Dict[str, Any]]) -> Dict[str, str]:
    """Tente d'instancier chaque mod√®le pour d√©tecter les erreurs de configuration."""
    instantiation_errors = {}
    
    for model_name, model_info in models.items():
        model_cls = model_info['class']
        
        try:
            # Tente de valider le mod√®le via sa m√©tadonn√©e sans cr√©er de tables
            model_cls.__table__.tometadata(model_cls.metadata, schema=model_cls.__table__.schema)
        except Exception as e:
            error_msg = f"{type(e).__name__}: {str(e)}\n{traceback.format_exc()}"
            instantiation_errors[model_name] = error_msg
    
    return instantiation_errors

def validate_sqlalchemy_models() -> Dict[str, Any]:
    """Valide tous les mod√®les SQLAlchemy et retourne un rapport des erreurs."""
    models = find_sqlalchemy_models()
    
    if not models:
        return {"status": "error", "message": "Aucun mod√®le SQLAlchemy trouv√©."}
    
    report = {
        "status": "success",
        "total_models": len(models),
        "models_with_errors": 0,
        "errors": {}
    }
    
    # V√©rifier les noms r√©serv√©s
    for model_name, model_info in models.items():
        model_errors = []
        
        reserved_name_errors = check_reserved_names(model_info['class'])
        if reserved_name_errors:
            model_errors.extend(reserved_name_errors)
        
        if model_errors:
            report["errors"][model_name] = {
                "file_path": model_info['file_path'],
                "reserved_names": reserved_name_errors
            }
    
    # V√©rifier l'int√©grit√© des relations
    relation_errors = check_relationship_integrity(models)
    for model_name, errors in relation_errors.items():
        if model_name not in report["errors"]:
            report["errors"][model_name] = {
                "file_path": models[model_name]['file_path'],
                "relation_errors": []
            }
        report["errors"][model_name]["relation_errors"] = errors
    
    # V√©rifier les noms de tables
    table_name_errors = check_table_names(models)
    for model_name, errors in table_name_errors.items():
        if model_name not in report["errors"]:
            report["errors"][model_name] = {
                "file_path": models[model_name]['file_path'],
                "table_name_errors": []
            }
        report["errors"][model_name]["table_name_errors"] = errors
    
    # Valider l'instanciation des mod√®les
    instantiation_errors = validate_class_instantiation(models)
    for model_name, error in instantiation_errors.items():
        if model_name not in report["errors"]:
            report["errors"][model_name] = {
                "file_path": models[model_name]['file_path'],
                "instantiation_error": ""
            }
        report["errors"][model_name]["instantiation_error"] = error
    
    # Mettre √† jour le nombre de mod√®les avec des erreurs
    report["models_with_errors"] = len(report["errors"])
    
    return report

def print_report(report: Dict[str, Any]) -> None:
    """Affiche le rapport de validation des mod√®les de mani√®re lisible."""
    print("=" * 80)
    print(f"RAPPORT DE VALIDATION DES MOD√àLES SQLALCHEMY")
    print("=" * 80)
    print(f"Mod√®les analys√©s: {report['total_models']}")
    print(f"Mod√®les avec erreurs: {report['models_with_errors']}")
    print("=" * 80)
    
    if report["models_with_errors"] == 0:
        print("‚úÖ Aucune erreur d√©tect√©e dans les mod√®les !")
        return
    
    for model_name, errors in report["errors"].items():
        print(f"\nüìÅ MOD√àLE: {model_name}")
        print(f"   Fichier: {errors['file_path']}")
        
        if "reserved_names" in errors and errors["reserved_names"]:
            print("\n   ‚ùå NOMS R√âSERV√âS:")
            for error in errors["reserved_names"]:
                print(f"      - {error}")
        
        if "relation_errors" in errors and errors["relation_errors"]:
            print("\n   ‚ùå ERREURS DE RELATION:")
            for error in errors["relation_errors"]:
                print(f"      - {error}")
        
        if "table_name_errors" in errors and errors["table_name_errors"]:
            print("\n   ‚ùå ERREURS DE NOM DE TABLE:")
            for error in errors["table_name_errors"]:
                print(f"      - {error}")
        
        if "instantiation_error" in errors and errors["instantiation_error"]:
            print("\n   ‚ùå ERREUR D'INSTANCIATION:")
            error_lines = errors["instantiation_error"].split("\n")
            for line in error_lines[:10]:  # Limiter √† 10 lignes pour lisibilit√©
                print(f"      {line}")
            if len(error_lines) > 10:
                print(f"      ... ({len(error_lines) - 10} lignes suppl√©mentaires)")
        
        print("-" * 80)

def main():
    """Fonction principale qui ex√©cute la validation des mod√®les."""
    print("Validation des mod√®les SQLAlchemy en cours...")
    report = validate_sqlalchemy_models()
    print_report(report)
    
    # Retourne un code d'erreur si des probl√®mes ont √©t√© d√©tect√©s
    return 1 if report["models_with_errors"] > 0 else 0

if __name__ == "__main__":
    sys.exit(main()) 