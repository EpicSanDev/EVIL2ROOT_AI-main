import os
import logging
import asyncio
import schedule
import time
from datetime import datetime, timedelta
import threading
from typing import Dict, List, Any, Optional
import json
import pandas as pd
import numpy as np
from dotenv import load_dotenv
import pathlib

from app.telegram_bot import TelegramBot
from app.models.news_retrieval import NewsRetriever
from app.daily_analysis_bot import DailyAnalysisBot
import yfinance as yf

# Importation des mod√®les existants
from app.models.price_prediction import PricePredictionModel
from app.models.sentiment_analysis import SentimentAnalyzer, MarketRegimeDetector
from app.models.transformer_model import FinancialTransformer
from app.models.risk_management import RiskManagementModel
from app.models.indicator_management import IndicatorManagementModel

# Configuration du logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('logs/market_analysis_scheduler.log'),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger('market_analysis_scheduler')

class MarketAnalysisScheduler:
    """
    Bot qui analyse les march√©s toutes les 30 minutes et envoie des signaux via Telegram.
    R√©cup√®re √©galement les actualit√©s toutes les 4 heures pour mettre √† jour les mod√®les.
    """
    
    def __init__(self, symbols: List[str]):
        """
        Initialise le scheduler d'analyse de march√©
        
        Args:
            symbols: Liste des symboles √† analyser
        """
        # Charger les variables d'environnement
        load_dotenv()
        
        # Configuration de base
        self.symbols = symbols
        self.telegram_bot = TelegramBot()
        self.news_retriever = NewsRetriever()
        
        # Initialisation du bot d'analyse (pour utiliser ses fonctionnalit√©s)
        self.analysis_bot = DailyAnalysisBot(symbols)
        
        # R√©pertoire des mod√®les
        self.models_dir = os.environ.get('MODELS_DIR', 'saved_models')
        pathlib.Path(self.models_dir).mkdir(exist_ok=True)
        
        # Initialisation des mod√®les de pr√©diction
        logger.info("Initialisation des mod√®les de pr√©diction...")
        self.price_prediction_models = {}
        self.sentiment_analyzers = {}
        self.market_regime_detectors = {}
        self.risk_managers = {}
        self.indicator_managers = {}
        
        # Initialiser les mod√®les pour chaque symbole
        for symbol in symbols:
            self.price_prediction_models[symbol] = PricePredictionModel()
            self.sentiment_analyzers[symbol] = SentimentAnalyzer()
            self.market_regime_detectors[symbol] = MarketRegimeDetector()
            self.risk_managers[symbol] = RiskManagementModel()
            self.indicator_managers[symbol] = IndicatorManagementModel()
        
        # Flag pour suivre l'√©tat d'entra√Ænement des mod√®les
        self.models_trained = False
        
        # Marquer la derni√®re mise √† jour des news
        self.last_news_update = None
        
        logger.info(f"Scheduler d'analyse de march√© initialis√© avec {len(symbols)} symboles")
    
    def start_scheduled_tasks(self):
        """D√©marre les t√¢ches planifi√©es"""
        # V√©rifier et entra√Æner les mod√®les avant de commencer
        if not self.models_trained:
            asyncio.run(self.telegram_bot.send_message("ü§ñ *PR√âPARATION DES MOD√àLES* ü§ñ\n\nEntra√Ænement des mod√®les en cours... Veuillez patienter."))
            self.train_all_models()
            asyncio.run(self.telegram_bot.send_message("‚úÖ Entra√Ænement des mod√®les termin√©. L'analyse de march√© va d√©marrer."))
        
        # Configurer le planning des analyses (toutes les 30 minutes)
        schedule.every(30).minutes.do(self.analyze_markets)
        
        # Configurer la mise √† jour des news (toutes les 4 heures)
        schedule.every(4).hours.do(self.update_models_with_news)
        
        # Ex√©cuter la premi√®re analyse et mise √† jour imm√©diatement
        self.analyze_markets()
        self.update_models_with_news()
        
        logger.info("T√¢ches planifi√©es configur√©es: analyse toutes les 30 minutes, mise √† jour des news toutes les 4 heures")
        
        # Boucle principale pour ex√©cuter les t√¢ches planifi√©es
        try:
            while True:
                schedule.run_pending()
                time.sleep(60)  # V√©rifier toutes les minutes
        except KeyboardInterrupt:
            logger.info("Scheduler arr√™t√© par l'utilisateur")
    
    def train_all_models(self):
        """Entra√Æne tous les mod√®les n√©cessaires pour les analyses"""
        logger.info("D√©marrage de l'entra√Ænement des mod√®les pour tous les symboles...")
        
        try:
            # Utiliser la m√©thode d'entra√Ænement du bot d'analyse
            self.analysis_bot.train_all_models()
            
            # Marquer les mod√®les comme entra√Æn√©s
            self.models_trained = True
            logger.info("Tous les mod√®les ont √©t√© entra√Æn√©s avec succ√®s")
            
        except Exception as e:
            logger.error(f"Erreur pendant l'entra√Ænement des mod√®les: {e}")
            raise
    
    def analyze_markets(self):
        """Analyse les march√©s et envoie des signaux via Telegram"""
        logger.info("D√©marrage de l'analyse de march√©...")
        
        try:
            signals = []
            
            for symbol in self.symbols:
                logger.info(f"Analyse du march√© pour {symbol}")
                
                try:
                    # R√©cup√©rer les donn√©es de march√©
                    market_data = self.analysis_bot.fetch_market_data(symbol, period="3mo", interval="1d")
                    
                    # R√©cup√©rer les donn√©es fondamentales
                    fundamental_data = self.analysis_bot.fetch_fundamental_data(symbol)
                    
                    # R√©cup√©rer les news r√©centes
                    news = self.news_retriever.get_combined_news(symbol, max_results=5)
                    
                    # Faire des pr√©dictions
                    price_predictions = self.analysis_bot.predict_prices(symbol, market_data)
                    
                    # Analyse de sentiment
                    sentiment_analysis = self.analysis_bot.analyze_sentiment(symbol, market_data, news)
                    
                    # √âvaluation des risques
                    risk_assessment = self.analysis_bot.assess_risk(symbol, market_data, fundamental_data)
                    
                    # D√©terminer si un signal doit √™tre envoy√©
                    signal = self._generate_trading_signal(
                        symbol, 
                        market_data, 
                        price_predictions, 
                        sentiment_analysis, 
                        risk_assessment
                    )
                    
                    if signal:
                        signals.append(signal)
                        
                except Exception as e:
                    logger.error(f"Erreur lors de l'analyse de {symbol}: {e}")
            
            # Envoyer les signaux via Telegram
            if signals:
                timestamp = datetime.now().strftime("%Y-%m-%d %H:%M")
                message = f"üîç *SIGNAUX DE TRADING ({timestamp})* üîç\n\n"
                message += "\n\n".join(signals)
                
                asyncio.run(self.telegram_bot.send_message(message))
                logger.info(f"Signaux envoy√©s: {len(signals)} signaux")
            else:
                logger.info("Aucun signal √† envoyer")
            
        except Exception as e:
            logger.error(f"Erreur lors de l'analyse des march√©s: {e}")
            
            # Notification d'erreur
            error_message = f"‚ö†Ô∏è *ERREUR D'ANALYSE* ‚ö†Ô∏è\n\nUne erreur est survenue lors de l'analyse des march√©s: {str(e)}"
            asyncio.run(self.telegram_bot.send_message(error_message))
    
    def update_models_with_news(self):
        """Met √† jour les mod√®les avec les derni√®res actualit√©s"""
        logger.info("Mise √† jour des mod√®les avec les derni√®res actualit√©s...")
        
        try:
            # Mettre √† jour la date de derni√®re mise √† jour
            now = datetime.now()
            self.last_news_update = now
            
            # R√©cup√©rer les actualit√©s pour chaque symbole
            for symbol in self.symbols:
                logger.info(f"R√©cup√©ration des actualit√©s pour {symbol}")
                
                try:
                    # R√©cup√©rer les donn√©es de march√©
                    market_data = self.analysis_bot.fetch_market_data(symbol, period="3mo", interval="1d")
                    
                    # R√©cup√©rer les news r√©centes (plus que d'habitude pour l'entra√Ænement)
                    news = self.news_retriever.get_combined_news(symbol, max_results=20)
                    
                    if news:
                        # Mettre √† jour le mod√®le de sentiment
                        logger.info(f"Mise √† jour du mod√®le de sentiment pour {symbol} avec {len(news)} nouvelles actualit√©s")
                        self.sentiment_analyzers[symbol].update(market_data, news)
                        
                        # Enregistrer le mod√®le mis √† jour
                        model_path = os.path.join(self.models_dir, f"{symbol}_sentiment_model")
                        self.sentiment_analyzers[symbol].save(model_path)
                        
                    else:
                        logger.info(f"Aucune actualit√© trouv√©e pour {symbol}")
                        
                except Exception as e:
                    logger.error(f"Erreur lors de la mise √† jour du mod√®le pour {symbol}: {e}")
            
            # Envoyer un message de confirmation
            update_message = f"üì∞ *MISE √Ä JOUR DES MOD√àLES* üì∞\n\nLes mod√®les ont √©t√© mis √† jour avec les derni√®res actualit√©s.\nProchaine mise √† jour dans 4 heures."
            asyncio.run(self.telegram_bot.send_message(update_message))
            
            logger.info("Mise √† jour des mod√®les termin√©e")
            
        except Exception as e:
            logger.error(f"Erreur lors de la mise √† jour des mod√®les: {e}")
            
            # Notification d'erreur
            error_message = f"‚ö†Ô∏è *ERREUR DE MISE √Ä JOUR* ‚ö†Ô∏è\n\nUne erreur est survenue lors de la mise √† jour des mod√®les: {str(e)}"
            asyncio.run(self.telegram_bot.send_message(error_message))
    
    def _generate_trading_signal(self, symbol, market_data, price_predictions, sentiment_analysis, risk_assessment):
        """
        G√©n√®re un signal de trading bas√© sur les analyses
        
        Returns:
            Signal format√© ou None si pas de signal
        """
        # Extraire les donn√©es pertinentes
        current_price = market_data.iloc[-1]['Close'] if not market_data.empty else 0
        
        # Prix pr√©dits
        next_day_price = price_predictions.get('next_day_prediction', current_price)
        three_day_price = price_predictions.get('three_day_prediction', current_price)
        week_prediction = price_predictions.get('week_prediction', current_price)
        
        # Sentiment et r√©gime de march√©
        market_sentiment = sentiment_analysis.get('market_sentiment', 'neutral')
        news_sentiment = sentiment_analysis.get('news_sentiment', 'neutral')
        market_regime = sentiment_analysis.get('market_regime', 'neutral')
        
        # Risque
        risk_level = risk_assessment.get('risk_level', 'medium')
        stop_loss = risk_assessment.get('recommended_stop_loss', current_price * 0.95)
        take_profit = risk_assessment.get('recommended_take_profit', current_price * 1.05)
        
        # Calculer la probabilit√© de mouvement et la direction
        price_change_pct = ((next_day_price / current_price) - 1) * 100
        three_day_change_pct = ((three_day_price / current_price) - 1) * 100
        week_change_pct = ((week_prediction / current_price) - 1) * 100
        
        # D√©terminer la direction
        direction = None
        signal_strength = 0
        
        # R√®gles de g√©n√©ration de signaux
        # 1. Direction bas√©e sur la pr√©diction du prix
        if price_change_pct > 1.5 or three_day_change_pct > 3 or week_change_pct > 5:
            direction = "ACHAT"
            signal_strength += 1
        elif price_change_pct < -1.5 or three_day_change_pct < -3 or week_change_pct < -5:
            direction = "VENTE"
            signal_strength += 1
        
        # 2. Sentiment influence la force du signal
        if market_sentiment == "bullish" and news_sentiment == "positive":
            if direction == "ACHAT":
                signal_strength += 1
            elif direction == "VENTE":
                signal_strength -= 0.5
        elif market_sentiment == "bearish" and news_sentiment == "negative":
            if direction == "VENTE":
                signal_strength += 1
            elif direction == "ACHAT":
                signal_strength -= 0.5
        
        # 3. R√©gime de march√© influence la force du signal
        if market_regime == "trending_up" and direction == "ACHAT":
            signal_strength += 1
        elif market_regime == "trending_down" and direction == "VENTE":
            signal_strength += 1
        elif market_regime == "volatile":
            signal_strength -= 0.5
        
        # 4. Risque influence la force du signal
        if risk_level == "low":
            signal_strength += 0.5
        elif risk_level == "high":
            signal_strength -= 0.5
        
        # Ne g√©n√©rer un signal que si la force est suffisante
        if direction and signal_strength >= 1.5:
            # Emoji en fonction de la direction
            emoji = "üü¢" if direction == "ACHAT" else "üî¥"
            
            # Formatage du signal
            signal = f"{emoji} *SIGNAL: {direction} {symbol}* {emoji}\n\n"
            signal += f"üìä *Prix actuel:* {current_price:.2f}\n"
            signal += f"üîÆ *Pr√©diction √† 1 jour:* {next_day_price:.2f} ({price_change_pct:.2f}%)\n"
            signal += f"üîÆ *Pr√©diction √† 3 jours:* {three_day_price:.2f} ({three_day_change_pct:.2f}%)\n"
            signal += f"üîÆ *Pr√©diction √† 1 semaine:* {week_prediction:.2f} ({week_change_pct:.2f}%)\n\n"
            signal += f"üß† *Sentiment:* {market_sentiment.capitalize()} (march√©), {news_sentiment.capitalize()} (news)\n"
            signal += f"üìà *R√©gime de march√©:* {market_regime.replace('_', ' ').capitalize()}\n"
            signal += f"‚ö†Ô∏è *Niveau de risque:* {risk_level.capitalize()}\n\n"
            signal += f"üõë *Stop Loss recommand√©:* {stop_loss:.2f}\n"
            signal += f"üéØ *Take Profit recommand√©:* {take_profit:.2f}\n"
            signal += f"üí™ *Force du signal:* {signal_strength:.1f}/3.0\n"
            
            return signal
        
        return None

def run_market_analysis_scheduler():
    """Fonction principale pour ex√©cuter le scheduler d'analyse de march√©"""
    # Charger la liste des symboles depuis les variables d'environnement
    load_dotenv()
    
    # Lire les symboles √† analyser
    symbols_str = os.environ.get('TRADING_SYMBOLS', '')
    if symbols_str:
        symbols = [s.strip() for s in symbols_str.split(',')]
    else:
        # Symboles par d√©faut si non sp√©cifi√©s
        symbols = [
            "AAPL", "MSFT", "AMZN", "GOOGL", "META", "TSLA", "NVDA", 
            "BTC-USD", "ETH-USD", "XRP-USD", "SOL-USD", "ADA-USD",
            "EURUSD=X", "GBPUSD=X", "USDJPY=X"
        ]
    
    logger.info(f"D√©marrage du scheduler d'analyse de march√© avec {len(symbols)} symboles")
    
    # Cr√©er et d√©marrer le scheduler
    scheduler = MarketAnalysisScheduler(symbols)
    
    try:
        scheduler.start_scheduled_tasks()
    except KeyboardInterrupt:
        logger.info("Scheduler arr√™t√© par l'utilisateur")
    except Exception as e:
        logger.error(f"Erreur critique dans le scheduler: {e}")
        
        # Notification d'erreur critique
        try:
            error_message = f"üö® *ERREUR CRITIQUE* üö®\n\nLe scheduler d'analyse de march√© a rencontr√© une erreur critique et s'est arr√™t√©: {str(e)}"
            asyncio.run(scheduler.telegram_bot.send_message(error_message))
        except:
            pass

if __name__ == "__main__":
    run_market_analysis_scheduler() 